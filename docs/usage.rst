.. currentmodule:: pypillometry

Overview
========

`pypillometry` is a Python package for analyzing pupillometric data, providing a comprehensive toolkit for preprocessing, analyzing, and visualizing pupil size measurements and eye-tracking data. The package is built around the :class:`pypillometry.EyeData`, :class:`pypillometry.PupilData`, and :class:`pypillometry.GazeData` classes, which serves as the main interface for handling pupillometric/eyetracking datasets. 

- :class:`PupilData`: If you have only pupillometric data, use this class.
- :class:`GazeData`: If you only have gaze data, use this class.
- :class:`EyeData`: If you have both gaze and pupillometric data, use this class.


.. autosummary::

    EyeData
    GazeData
    PupilData
    GenericEyeData


Importing eye-data
------------------

So far, the package provides functions to load data from Eyelink's .edf files using the [`eyelinkio`](https://github.com/scott-huberty/eyelinkio) package via the function :func:`GenericEyeData.from_eyelink`. This function will import the raw data stored in the EDF file as well as all "message" triggers. It is also possible to use Python's excellent functionality to parse text-based datafiles (most eyetrackers allow to export their proprietory format into a text-based one). For example, Eyelink's `ASC-format <http://download.sr-support.com/dispdoc/page25.html>`_ generated by the EDF2ASC conversion tool outputs space-separated data that can be easily loaded using the `I/O functionality of the pandas package <https://pandas.pydata.org/pandas-docs/stable/reference/io.html>`_ . 
Once the data has been manually parsed into :mod:`numpy`-arrays, it can be converted into a :class:`~pypillometry.PupilData`, :class:`~pypillometry.GazeData`, or :class:`~pypillometry.EyeData` object.

:mod:`pypillometry` provides functions to load data from local data directories (:func:`~pypillometry.load_study_local`) and from OSF-projects (:func:`~pypillometry.load_study_osf`) based on a user-provided configuration file (:ref:`/examples/pypillometry_conf.py`).

The package comes with a few example datasets for convenience (see :ref:`this notebook </example_datasets.ipynb>`). These can be loaded using the :func:`~pypillometry.get_example_data()` function.

Please refer to the following notebooks for more information:

- :ref:`An example for importing data from Eyelink EDF-files </importdata_edf.ipynb>`
- :ref:`An example for importing data from Eyelink ASC-files </importdata_asc.ipynb>`
- :ref:`Example datasets included in the package </example_datasets.ipynb>` 
- :ref:`Providing a configuration file for loading/sharing data from a local directory or OSF </examples/share_study.rst>`


Pipeline-based processing
-------------------------

:py:mod:`pypillometry` implements a pipeline-like approach where each operation executed on a :class:`~pypillometry.PupilData`,-:class:`~pypillometry.GazeData` or :class:`~pypillometry.EyeData`-object returns a copy of the (modified) object. This enables the "chaining" of commands as follows:

.. code-block:: python

    d=pp.get_example_data("rlmw_002_short").pupil_blinks_detect().blinks_merge().pupil_lowpass_filter(3).downsample(50)

This command loads an example data-file, applies a 3Hz low-pass filter to it, downsamples the signal to 50 Hz, detects blinks in the signal and merges short, successive blinks together. The final result of this processing-pipeline is stored in object `d`. This object stores also the complete history of the operations applied to the dataset and allows to transfer it to a new dataset.

See the following page more on this: 

- :ref:`Pipeline-based processing in pypillometry </pipes.ipynb>`

Data modalities/variables and monocular vs. binocular data
----------------------------------------------------------

:mod:`pypillometry` supports monocular and binocular data and allows to process several data modalities. The package ensures that all timeseries always have the same length/dimension such that all data modalities are aligned. The data are stored internally as an :class:`~pypillometry.EyeDataDict`-object which is a dictionary of :class:`numpy.ndarray`-objects that are constrained to have the same shape. In addition, the keys of the dictionary are of the form "<eye>_<variable>", e.g., ``left_pupil`` or ``right_x``.

Most functions that operate on :class:`~pypillometry.EyeData`-objects allow to specify the eye and variable to operate on with optional arguments ``eye=`` and ``variable=`` (per default, all eyes and all variables are processed). Functions that can potentially operate on all modalities are implemented as methods of :class:`~pypillometry.GenericEyeData` while functions that are specific to pupillometric or eye-tracking data are implemented as methods of :class:`~pypillometry.PupilData` or :class:`~pypillometry.GazeData`. However, all objects be they :class:`~pypillometry.PupilData`, :class:`~pypillometry.GazeData` or :class:`~pypillometry.EyeData` inherit from :class:`~pypillometry.GenericEyeData` and therefore support the same set of operations. 

Finally, new variables (or even "eyes") can be created and added to the object. For example, when combining the data from both eyes, one can create a new variable that contains the average of the left and right pupil size which might be called "average_pupil". In that case, the ``eye="average"`` and ``variable="pupil"`` arguments should be used to access this new variable.

Please see the following example for more details: 

- :ref:`Processing monocular and binocular data </eyes_and_variables.ipynb>`

Plotting data
-------------

Each pypillometry object has a `.plot` attribute that gives access to the plotting functionality. Depending on the type of the object, the plotting functionality will be different. For example, :class:`~pypillometry.GazeData` objects (and also :class:`~pypillometry.EyeData` objects which inherit from that class) support the plotting of heatmaps or scanpaths.

Here is an overview of the plotting functionality:

.. autosummary::

    PupilPlotter
    GazePlotter
    EyePlotter
    GenericEyePlotter
    
 
Analyzing pupillometric data
----------------------------


Analyzing eye-tracking data
---------------------------

work in progress


Pre-processing data
-------------------

Assuming you have generated a :class:`~pypillometry.pupildata.PupilData` object, a range of pre-processing functions are available. The main pre-processing issues with pupillometric data are:

- artifacts and missing data due to blinks (these can usually be corrected/interpolated)
- missing data/artifacts from other sources (e.g., looking away, eyetracker losing pupil for other reasons)
- smoothing/downsampling to get rid of high-freq low-amp noise



Handling Blinks
^^^^^^^^^^^^^^^

Pupillometric data usually contain blinks which show up as missing data in the signal where the eyetracker is unable to record the size of the pupil.
A range of functions are available for detecting and interpolating blinks. 

More details and an example can be found in the notebook: :ref:`An example for how to handle blinks </blinks.ipynb>`

A fully worked-out example of a real study can be found in this notebook: :ref:`Preprocessing of a full dataset with multiple subjects </preproc_example_pavlov.ipynb>`

The following is a list of functions for that purpose. Note that the functions take multiple arguments that control the algorithms behaviour. It is often crucial to adjust the parameters on an individual level since the artifacts tend to be quite dissimilar between subjects (but usually stable within-subject). All arguments are documented in the :ref:`API-docs </api.rst>`.

.. autosummary::

    PupilData.blinks_detect
    PupilData.blinks_interpolate    
    PupilData.blinks_interp_mahot
    PupilData.blinks_merge
    PupilData.blinks_plot

Smoothing/low-pass filtering
^^^^^^^^^^^^^^^^^^^^^^^^^^^^

In most cases, pupillometric data should be low-pass filtered (e.g., using a cutoff of 4 Hz `Jackson & Sirois, 2009 <https://doi.org/10.1111/j.1467-7687.2008.00805.x>`_) or smoothed in other ways (e.g., with a running-window). 

Tge following is a list of functions for smoothing:

.. autosummary::

    PupilData.lowpass_filter
    PupilData.smooth_window
    PupilData.downsample

Changing/Slicing data
^^^^^^^^^^^^^^^^^^^^^

Often, pupillometric data needs to be trimmed, e.g., to remove pre-experiment recordings or to remove unusable parts of the data (:func:`PupilData.sub_slice`). The timing should usually be realigned to the start of the experiment (:func:`PupilData.reset_time`). Furthermore, a scaling (e.g., Z-transform) of the pupil-data can be useful for comparing multiple subjects (:func:`PupilData.scale`).

The following is a list of available functions for these purposes:

.. autosummary::

    PupilData.sub_slice
    PupilData.copy
    PupilData.scale
    PupilData.unscale
    PupilData.reset_time

Plotting/Summarizing Data
-------------------------


Plotting
^^^^^^^^

It is crucial to validate preprocessing steps by visually inspecting the results using plots. Therefore, :mod:`pypillometry` implements several plotting facilities that encourage active exploration of the dataset. 

Please see the tutorial :ref:`Plotting of pupillometric data </plotting.ipynb>` for more details.


.. autosummary::

    PupilData.plot
    PupilData.plot_segments
    PupilData.blinks_plot
    plotpd
    plotpd_ia
    PupilData.get_erpd



Inspecting/Summarizing
^^^^^^^^^^^^^^^^^^^^^^

The package also provides several functions for summarizing datasets. Simply `print()`ing a :class:`PupilData` object gives a readable summary of the main properties of the dataset and also prints the complete history of the results. By calling :func:`PupilData.summary`, summary data can be arranged and summarized in tabular form. 

See the notebook :ref:`Summarizing pupillometric data </summary.ipynb>` for more details.

.. autosummary::

    PupilData.summary
    PupilData.stat_per_event 
    PupilData.get_erpd
    
Event-Related Pupil Dilation
^^^^^^^^^^^^^^^^^^^^^^^^^^^^

The average pupillometric signal, timelocked to repeating events during the experiment, is referred to as "Event-related pupil dilation" or ERPD. In :mod:`pypillometry`, the functionality for this is implemented in the class :class:`pypillometry.erpd.ERPD`.

Running :func:`PupilData.get_erpd` returns an Object of class :class:`ERPDSingleSubject`. This object has functions for plotting and summarising the event-related pupillary dilation. 

:ref:`Here is an example notebook for for how to work with ERPDs </erpds.ipynb>`.


.. autosummary::

    PupilData.get_erpd
    
.. currentmodule:: pypillometry.erpd

.. autosummary::

    group_erpd
    ERPD.summary
    ERPD.plot

    

Modeling the pupillometric signal
---------------------------------

For some applications, it is interesting to model the full pupillometric signal as consisting of a (tonic) baseline and a (phasic) response component. 
The package implements novel algorithms developed in our lab and documentation will become available here.

More details are availabel in this notebook: :ref:`Modeling the pupillometric signal </modeling.ipynb>`.

.. currentmodule:: pypillometry.pupildata

.. autosummary::

    PupilData.estimate_baseline
    PupilData.estimate_response    
    PupilData.stat_per_event
    
Artificial Data
---------------

For validation and testing purposes, it can be useful to generate artificial datasets. The package implements a :class:`FakePupilData` as inheriting from regular :class:`PupilData` and therefore shares all its functionality. In addition to that, :class:`FakePupilData` stores "ground-truth" data and parameters that was used while creating the artificial data.

The function :func:`create_fake_pupildata` allows to quickly create datasets generating according to a provided experimental structure (see the functions documentation for an overview over the many available options).

.. autosummary::
    FakePupilData
    create_fake_pupildata


